*UJ PC$̋Ha
*UH/c+۷A-]4g
*UHCE<HB?AÙ4>AAÙ4 Q/AÙ4 ysSAT/ß ]Ù4>}E"ƓP:Χ I"$ϝ3 QgDQ*P"3bAU')HE QP)P(3*S3SP(I0Ih Q
Ah4 6A/$
^LuF γFO)ũ	%yT/ŝ#ũ"ŗ'ˋ$)O
'̉lAq"Ù
OS&I#IgY}(S'̉l]>yA#IhGaA
*GSS)ũ#y$ ]"G(}A<.#ճ>AΉE(y_]4ayA	* I)GaA$
`γ
T
^LuF γFyqj I:,ЋEAφyqj I<uέԿb˿ŝEAφyADTGaA
'̉lA$өA3S)ũDP.I>yA#I)Aq"Ù
T(#I(S*GAHADP1})ũ	*KAHADP2}CGA)O
XA(E Q)P)O)ũ	, yT/͟QoХ3`ҳEA_ߟWA"]>}E<$T<gIeA-<uϥءH$XA>})Qyqj I0yύ`ˋY]>}/>OE<$T<gIeA-<uءH$>}_>}RiNAϝuCjEA §RRiN[OφyqjGAT/ß$4"usSyqj S̓u<uϝu&IPI CE<΋_ԙ4 Q	"ASTE
$A"ҧ
AS͋H)T#E# Q
EA0gYA̫^Vu'AéF#I}#E<SQΧ$
Qċs(A	!ϝu)SéUOAl 6(Ih4 6A/SCSAiR)!ҋ5"cA<uέԿb˿ŝEAφyADTGaA
'̉lA$өA3S)ũDP.Ih<SQ$
P# Q#Al)AA<.#ճ_>yqj IhNOAO ysDA<{.0AE<uέة'ˋ$E<*ҝCSAԪNA_>}R`A
P< QyA
Fy4AbDCSA_A"}E<$P$/Ћԟqg ]P>}P(#ճ(ċs(Q"G*P<4 6A/yqj #ճKA(RT	%SE(PF
P<T'T̉lcϞSKAHADP2}CGA_ՒN/ԟqg ]P>S<{.7AE<SQ#E<uέة'ˋ$yQjU$ԧT}** O(R)OP$t͋EAWPi}6iQ>O)E ]Χ.>O}E>S
* yQjUϔ}E>yTԫSťS>}S:Χ$ө,Ћ
APlusS
_AÙ4 ysSAT/ԳP.S̓u>A񢆊ycIPhEAEAЩ3AHH&Eh)SARFGaA$
`γ
+AT()O
AhKA(E QaSA/&I#IgY}	%S$өA3S񢆊yqj Ih:gVIj_eߩA"}E<SQ"G*P# QDTyiAl _)AA"G($P(KA(ċs(QԠ6yqj NOA/<$'T̉leϐ< J={T }P(S:gVIlTŝEAE<SQ"G*P# QDTyiAl _)AA"G($P(KA(ċs(QԠ6yqj NOA/<$'T̉leϐ< J={TX}SAhO$2c:řEiA"}ϔGA(AaSAE&A_1fDa̓u.I>}#E(y_]1ayA	 ҏhV$1Sq"Ù
(I4A/+E aԟH#IAl>Q̧
^Vu'AéF#I}	)ɏhOkE 6F#IFyqj I4A_4"̓u.I* }E<$3)yT/ҋiNEAφyqj IrcA_1Ah$AaSAE&AkA.IrcA+Ah.})J={T>O(R$QIfSAǧ
Qċs(A	 ҏhOkE 6F#IV)yaԟH*֋u'Al 6F$1SéUOAl 6)O)ũ	 ҏh:,ЋiA"A̧P2b̉h$AǧPrc΃.I>O)ũ	 §'΋MqP9AkA.IrcA+Ah.})J={T>O)ũ	 §'΋MqP3A_T٩4"]P>}FQ^A#gyqj I0yύ`ˋN>S<{. }SAhO$2qAϔGA,>O)ũ	 §'΋MqP1oAϔGAAaSAE&3>}#E(y_]1eyqj I0yύ`ˋ[ 3>}#E(y_]8AE<$T<gIeA,N>S<{.}SAhO$2mAϔGA(AaSAE& 3>}#E(y_]1iyqj I0yύ`ˋ\ 3>}/>OGA->O(R$4A(E Q қhOkE 6F#IFyT/ŝ'EO.IA қh:Χ$өEAφyqj I0yύ`ˋP[yT/ŝ#ũbNA"]>] қh.})QyA
FyT/ŝ ӧb]P"<2}SAhO$2c('I >>
>)>>>
<RETURN <:P_ENV$GET_TYPE .$E .$ABS >.RTN >
><:RETURN-ERROR>>
<SETG :P_TYPE$TYPE :TYPESPEC >
<SET PROCLIST <CONS :P_FIELDSPECLIST .PROCLIST>> 

<DEFINE :P_FIELDSPECLIST ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<VECTOR UVECTOR FIX FIX FIX>)
<PROG ($SPECS $K )#DECL ( ($SPECS )<VECTOR UVECTOR FIX FIX FIX>($K )<LIST FIX ANY>)

<SET $SPECS <ARRAY$CREATE 1 >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 20 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<PROG ()
<:P_ENV$ASSUME .$E "[fieldspeclist] in RECORD or ONEOF">
<RETURN .$SPECS .RTN >
>)>>>
<REPEAT () <COND (T 
<PROG ($SELS $T )#DECL ( ($SELS )<VECTOR UVECTOR FIX FIX FIX>($T )ANY )
<SET $SELS <:P_NAMELIST .$E >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 3 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<SET $T <:P_TYPE .$E >>
>)(T 
<PROG ()
<:P_ENV$ASSUME .$E ": type in fieldspec">
<SET $T <:P_ENV$GET_UNKNOWN_TYPE .$E >>
>)>>>
<PROG ($I K I)#DECL (($I K I)FIX)<SET I <ARRAY$LOW .$SELS >><SET K <ARRAY$HIGH .$SELS >><SET $I .I><REPEAT () <COND (<L? .K .$I > <RETURN>)> 
<PROG ()
<ARRAY$ADDH .$SPECS [<ARRAY$FETCH .$SELS .$I >.$T ]>
><SET $I <+ 1 .$I >>>>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 4 >
<:P_ENV$NEXT_TOKEN .$E >)
(<==? .TG 27 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN .$SPECS .RTN >
>)(T 
<PROG ()
<:P_ENV$ASSUME .$E "] in [fieldspeclist]">
<RETURN .$SPECS .RTN >
>)>>>
>) (T <RETURN>)>> 
><:RETURN-ERROR>>
<SETG :P_FIELDSPECLIST$TYPE (:ARRAY R$4871$2$0 )>
<SET PROCLIST <CONS :P_RETURNS .PROCLIST>> 

<DEFINE :P_RETURNS ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<VECTOR UVECTOR FIX FIX FIX>)
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 30 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN <:P_TYPELIST .$E #FALSE () >.RTN >
>)(T 
<RETURN <ARRAY$CREATE 1 >.RTN >)>>>
><:RETURN-ERROR>>
<SETG :P_RETURNS$TYPE (:ARRAY :TYPESPEC )>
<SET PROCLIST <CONS :P_YIELDS .PROCLIST>> 

<DEFINE :P_YIELDS ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<VECTOR UVECTOR FIX FIX FIX>)
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 43 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN <:P_TYPELIST .$E #FALSE () >.RTN >
>)(T 
<RETURN <ARRAY$CREATE 1 >.RTN >)>>>
><:RETURN-ERROR>>
<SETG :P_YIELDS$TYPE (:ARRAY :TYPESPEC )>
<SET PROCLIST <CONS :P_SIGNALS .PROCLIST>> 

<DEFINE :P_SIGNALS ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<VECTOR UVECTOR FIX FIX FIX>)
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 33 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN <:P_EXCEPTIONLIST .$E >.RTN >
>)(T 
<RETURN <ARRAY$CREATE 1 >.RTN >)>>>
><:RETURN-ERROR>>
<SETG :P_SIGNALS$TYPE (:ARRAY R$4871$2$1 )>
<SET PROCLIST <CONS :P_ARRAYTYPE .PROCLIST>> 

<DEFINE :P_ARRAYTYPE ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)ANY )
<PROG ($K $T )#DECL ( ($K )<LIST FIX ANY>($T )ANY )

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 20 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<PROG ()
<:P_ENV$ASSUME .$E "[type] in ARRAY[type]">
<RETURN <:P_ENV$GET_UNKNOWN_TYPE .$E >.RTN >
>)>>>
<SET $T <:P_TYPE .$E >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 27 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<:P_ENV$ASSUME .$E "] in ARRAY[type]">)>>>
<RETURN .$T .RTN >
><:RETURN-ERROR>>
<SETG :P_ARRAYTYPE$TYPE :TYPESPEC >
<SET PROCLIST <CONS :P_TYPELIST .PROCLIST>> 

<DEFINE :P_TYPELIST ( $E $EMPTYOK  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($EMPTYOK )<OR ATOM FALSE>(VALUE)<VECTOR UVECTOR FIX FIX FIX>)
<PROG ($TYPES $K )#DECL ( ($TYPES )<VECTOR UVECTOR FIX FIX FIX>($K )<LIST FIX ANY>)

<SET $TYPES <ARRAY$CREATE 1 >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 22 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<PROG ()
<:P_ENV$ASSUME .$E "(typelist)">
<RETURN .$TYPES .RTN >
>)>>>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 29 >
<COND (.$EMPTYOK 
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN .$TYPES .RTN >
>)(T 
#FALSE () )>)(T 
#FALSE () )>>>
<REPEAT () <COND (T 
<PROG ()
<ARRAY$ADDH .$TYPES <:P_TYPE .$E >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 4 >
<:P_ENV$NEXT_TOKEN .$E >)
(<==? .TG 29 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN .$TYPES .RTN >
>)(T 
<PROG ()
<:P_ENV$ASSUME .$E ") in (typelist)">
<RETURN .$TYPES .RTN >
>)>>>
>) (T <RETURN>)>> 
><:RETURN-ERROR>>
<SETG :P_TYPELIST$TYPE (:ARRAY :TYPESPEC )>
<SET PROCLIST <CONS :P_EXCEPTIONLIST .PROCLIST>> 

<DEFINE :P_EXCEPTIONLIST ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<VECTOR UVECTOR FIX FIX FIX>)
<PROG ($LIST $K )#DECL ( ($LIST )<VECTOR UVECTOR FIX FIX FIX>($K )<LIST FIX ANY>)

<SET $LIST <ARRAY$CREATE 1 >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 22 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<PROG ()
<:P_ENV$ASSUME .$E "(exceptionlist)">
<RETURN .$LIST .RTN >
>)>>>
<REPEAT () <COND (T 
<PROG ($N $TYPES )#DECL ( ($N )ANY ($TYPES )<VECTOR UVECTOR FIX FIX FIX>)
<SET $N <:P_NAME .$E >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 22 >
<SET $TYPES <:P_TYPELIST .$E #FALSE () >>)(T 
<SET $TYPES <ARRAY$CREATE 1 >>)>>>
<ARRAY$ADDH .$LIST [.$N .$TYPES ]>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 4 >
<:P_ENV$NEXT_TOKEN .$E >)
(<==? .TG 29 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN .$LIST .RTN >
>)(T 
<PROG ()
<:P_ENV$ASSUME .$E ") in (exceptionlist)">
<RETURN .$LIST .RTN >
>)>>>
>) (T <RETURN>)>> 
><:RETURN-ERROR>>
<SETG :P_EXCEPTIONLIST$TYPE (:ARRAY R$4871$2$1 )>
<SETG R$4871$2$0'(:RECORD :NAME :TYPESPEC )>
<SETG R$4871$2$1'(:RECORD :NAME (:ARRAY :TYPESPEC ))>
