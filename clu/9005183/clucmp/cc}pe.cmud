*UJ PC$̋Ha
*UH/ck۷AL2e
*UHCE<HB?AÙ4>AAÙ4 Q/AÙ4 ysSAT/ŝ!ҋ5"]Ù4>}E"ƓP:gVIt IQaASTE
$A"ҧ
AS͋H)T#E# Q
RhOgYA3PA( γgYA3}̫`γ
FyA
FO)E ßQG]A)E$2A)E yQaϥ#ũ.IQa}ßQG ]A)E$5A)Ey4AEP1A ҥ6RCjEA(<҉A$>yQaϥ#ũ.IQa}Y Ij_ORsDIj oRh>ԪNAE>yTԫSťS>}S:gVIt*YP }P)O_ՐCjEA_ՒCjEAE<PIC:gVIkߋՐ.S̓u>A񢆊ycIP$ŝ II"$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>QgFA0gYA̫`γ
FyA
FO)E ßQG]P>yQaϥ#ũ.I<҉Ah$RsDIj iEA˒IRsDIj mEAP<TIt}iR)!ҋ5"cRsDIj c$RsDIj c($RsDIj cH$>O:*ҝiROԏ_ՒNέ,Ћ_Ր>O(UAT/ŝ'EgVA_ՒNέyqj S̓u<uέԿb˿ŝRs$өϐDgEAT/ŝ#ũ"ŗ'ˋ I"$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>QfU/&I#IgY}#E<SQ Sq"Ù
(It)yaԟH*֋u'Al 6FSS)E$9A"}E< QgTIj ҥ6RSQP.It>ayA	& Ih Q
LA1A	%S$өA3SSLAßQG]P>}SKA_ՒS3.I>O ҥ6RA.It[y3$<҉A$$$_ßQP]P.ITTAƃQ(O)E yQaϥ#ũ<TIST$>]U' }<uQjUbҥ>O)ũP$/Ћԟqg$4"6sayjP:gVAj_eߩA_ՒGEwO>O)ũ)OiAΧ_ՒP.S̓u>A񢆊ycIP$eQ	"IfASTE
$A"ҧ
AS͋H)T#E# Q
EA/+E PA(#IgYA3PFVu'AéF#I}éUOAl 6A( γgYANƓVbyiAl _)O(R$ Q
S
^Vu'AéF#I}#EA yQaϥ#ũP.I>O(R$ISq"Ù
$ISl)yqj  ҥ6RSQP.It>}AhI)ՅN})ũ	$]/R`A
P< Q]h$<*ҝ_ O(R$	%Sq"Ù
(IƓ$
^LuF γFyqj IRsDIj oEAφyqj Ih:gVIpA"}E<TI1"HA)Ao$ΩAßQG]P>]>]]}RsDIj oEA& }<$cIAϟ>O)E yQaϥ#ũ<TIjCSN>]U' }<uQjUbҥ>O)ũP$e4"6sayjP:gVAbA_ՒP>O)ũ)OiAΧ_ՒN/ԟqg ]Ù4>}E"ƓP:gVIlTŝ
$Og΃(3LT(S(NQ q"Ù
(IOgYA36A( γgYAl yaԟH*֋u'Al 6FVu'AéF#I}3PA((3*S$өA3SP(It$	%Sq"Ù
(It)yaԟH*֋u'Al 6F$
cI
KA/&I#IgY}#EA yQaϥ#ũP.I>O)ũ	& yQaϥ#ũ.I>O!ϝ<G ҥ6RSQP.It>ayA	(EA(E Q"SéFLuF γϔA"y4A͙SiR))ũ'A)A(Ή
I#AßQG]"})O
iR)*RRsDIj qEAP0AE<҉*A$$ΩbDA& yQaϥ#ũP.IP>}E>Sq̧)A/yqj IhRsDIj ePTTAP(SSKA_ՒS3.I>O!ϝ<G)E$7A"}& }APlRfyQaϥ#ũ.I1A)QGfS
SE>SE<TI1"HAßQG ]P>]>O)E ].>O:*ҝiROԏ_ՒN/ԟqg$4"6sayjP:gVAlTŝP$*_AE<PIC:gVIj_3ΟRs$өϐDgEAT/ŝ#ũ$΋(AP E*If"A ΉiSA
TEfENSċs(A	"SéA( γA3PA(#I+E aԟH#IAl>yaԟH*֋u'Al 6FγgYA3}̫cI
FyA
FO)E yQaϥ#ũ.I.>O:*ҝiROԏ_ՒGI4"u3 }P)O_ՐGIYT/ŝ#ũ$΋>O)ũ)OiAΧ_ՒGAPI CE<΋_ՒGA IIOg΃(3LT(S(NQ q"Ù
(IOgYA36A( γgYAl yaԟH*֋u'Al 6FVu'AéF#I}3PA((I1)P(3*S3SP(S񢆊yQjU:gT0GARsDIj iEA˒IRRiN[OφyqjGAT/ŝ#ũ͋,ЋA*ԡS uέԿfA_ՒGAAÙ4 ysSAT/ŝ&API CE<΋_ՒMqo΃P(AP$Og΃(3LT(S(NQ q"Ù
(IOgYA36A( γgYAl yaԟH*֋u'Al 6FVu'AéF#I}3PA((IhөRgGA̫`γ
FyA
FO)E yRbE IeſfAßQG ]P>]>]U' }<uQjUbҥ>O)ũP$2ߝ3b4"ufAE<(RP 2ߝ3bYT/ŝ&AAÙ4 ysSAT/ŝ'E"֋PI CE<΋_ՒNE(AP E*If"A ΉiSA
TEfENSċs(A	"SéA( γA3PA(#I+E aԟH#IAl>yaԟH*֋u'Al 6FγgYA3}#E<SQ#Eċ*A׿kE)E$4A"}E>}P)O_ՐNE,uέ׿kEyqj S̓u<uέ'пkERs$өϐDgEAT/ŝ(O"֋ I"$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>SP(S񢆊yRbE I_AßQG ]P>}DP>O(UAT/ŝ(O"֋:gVI_AE<PIC:gVIj_.S̓u>A񢆊ycIP$/ɉ IIOg΃(3LT(S(NQ q"Ù
(IOgYA36A( γgYAl yaԟH*֋u'Al 6FVu'AéF#I}3PA((I1)P(3*S3SP(S񢆊yQjU:gT0Gĝ)E$4A"}$A˩T}E-T}E<#uέԿ1'$4"u1' }P)O_ՐGĝP$/ɉAÙ4 ysSAT/ŝ'EbNA)Oi}O"E3uέ׿1' Q	"Ih"$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>Q)Ώ
+AT()O
RiNAċ*A׿1' yQaϥ#ũ.I.Ih.>O:*ҝiROԏ_ՒNĝ,ЋĝyjP:gVAkߓ,uέ׿1' }S(Rs$ө!ϝhP$/ԳP.S̓u>A񢆊ycIP$/ԳP(AP$("$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>Q S$өA3QfU0gYA#E<SQ#E<SQP)O)ũXQ:yv QTR)yc//Aԥ3S A)SEԫS<uhE0GYRsDIj c($$(EcR<*ҝELc(R(Iqf y$ ]OiGS#E# Q
SөRgGA#E_ՒEH$)ԥ3uq9ow ҉ gu$>c<*ҝELe(R(Ircy$ ]OiGS#E# Q
SөRgGA#E_ՒEH$)ԥ3uq9v ;r(Ru,Ћ iT] E)ɏ})E>OyQjURsDIj cH$RRiN[OφyqjGAT/ŝ#ũ,Ћ,ЋYEyjP:gVAj_4"YT/ŝ#ũ,Ћyqj S̓u<uέԿΟԳP.S̓u>A񢆊ycIP$/՝sם,Ћ
$Og΃(3LT(S(NQ q"Ù
(IOgYA36A( γgYAl yaԟH*֋u'Al 6FVu'AéF#I}3PA((3*S3SP(S񢆊yQjURsDIj cH$RRiN[OφyqjGAT/ŝ#ũgK_4"4"uhEa}P)O_ՐGΗοhEA_ՒGΗοhEAE<PIC:gVIj_1/ű.S̓u>A񢆊ycIP$/ءH I"$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>QfU0gYA#E<SQ#EԫS<u(RItO$2gA)E$1eEAϗRRiN[OφyqjGAT/ŝ#ũĿ(RIhEAQlPyjP:gVAj_1/ű,uέԿPb_) }S(Rs$ө!ϝhP$t͋Rs$өϐDgEAT/ŝ ӧbQ	"I AЩ3AHH&Eh)SARFGaA$
`γ
W5)Ώ
FyA
FOP$T.ISRgGIsCSRgGIsCm|$j }H|8rywtEP>OO*ԡS uέiӫP,uέiӫP>O)ũ)OiAΧ_ՒEHPI CE<΋_ՒEH IW(D"$ϝ3 QgDQ*P"3bAU')HE QP)yaԟH γgYAl PA( γAéUOAl 6<OkE 6F#IgYA3P>QYA4R(IcSl SP(IPu$IA(E Q)P(IiA/+E aԟH#IAl>Q& SéUOAl 6(I(ƓSFAßQG ]P>}:3"$]<҉A$I(Uh$	EE<ufEIjSA# ]YAE<ufEIjCA# Gr ҃u"A,>OFRP.IÑ4é9AE<$4 yQaϥ#ũ.I>O(R$ISq"Ù
$ISl)yqj  ҥ6RL$4 })ũ<TIcA(A>yqj I(I}Ћ5(S!ϝ<KA$})E>SyA
FyT*_AiR)#Er.IiA$}# }:3"!]#iAi gH)ũ	$yh]P>}φyQ̋*ԧFA__EE<$RsDIj sEAφyqj I(}:gVIbA"]P>O)Ej Q(C(y3$5`AßQGy4Aԇ$$0AE<SQ#E<ufEIjCA# Gr ҃u"Al>OP'ˋRsDIj e ҥ6RF ]& ]P>}# }SIAgTI1" ]P1AφyT/ŝ(Eh$IAE>S
* yQjUϔ}E<ufEIjCA# Gr ҃u"A,>O!ϝ<GDRsDIj gEAφyQaϥ(U.I$>Sq̧)A/}EAE<UTPROP :P_ENV ERR ,:P_ENV$ERR >
<SET PROCLIST <CONS :P_ENV$GET_ERR .PROCLIST>> 

<DEFINE :P_ENV$GET_ERR ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >(VALUE)FIX )
<PROG ()

<RETURN <RECORD$GET 3 .$E >.RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$GET_ERR$TYPE :INT >
<PUTPROP :P_ENV GET_ERR ,:P_ENV$GET_ERR >
<SET PROCLIST <CONS :P_ENV$PUT_ERR .PROCLIST>> 

<DEFINE :P_ENV$PUT_ERR ( $E $DEG  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >($DEG )FIX )
<PROG ()

<COND (<INT$GT .$DEG <RECORD$GET 3 .$E >>
<RECORD$PUT 3 .$E .$DEG >)(T 
#FALSE () )>
>DONE >
<PUTPROP :P_ENV PUT_ERR ,:P_ENV$PUT_ERR >
<SET PROCLIST <CONS :P_ENV$SCAN .PROCLIST>> 

<DEFINE :P_ENV$SCAN ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >(VALUE)<LIST FIX ANY>)
<PROG ($F $C )#DECL ( ($F )ANY ($C )CHARACTER )

<SET $F <RECORD$GET 5 .$E >>
<REPEAT () <COND (<AND <APPLYOP :FILE$EOF$TYPE NOT <:FILE$EOF .$F >() ><:IS_FORMAT <:FILE$PEEK .$F >>>
<PROG ()
<COND (<CHAR$EQUAL <:FILE$GETC .$F >#CHARACTER 10 >
<RECORD$PUT 7 .$E <INT$ADD <RECORD$GET 7 .$E >1 >>)(T 
#FALSE () )>
>) (T <RETURN>)>> 
<COND (<:FILE$EOF .$F >
<RETURN <ONEOF$MAKE 11 NIL >.RTN >)(T 
#FALSE () )>
<SET $C <:FILE$GETC .$F >>
<COND (<:IS_ALPHA .$C >
<RETURN <:IDENTTAB$GET_TOKEN <RECORD$GET 4 .$E ><:P_ENV$IDENT_OR_KEY .$E .$C >>.RTN >)(T 
#FALSE () )>
<COND (<:IS_NUM .$C >
<RETURN <ONEOF$MAKE 18 <:INTTAB$GET_INTID <RECORD$GET 6 .$E ><:P_ENV$INTLIT .$E .$C >>>.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 37 >
<PROG ()
<RECORD$PUT 7 .$E <INT$ADD <RECORD$GET 7 .$E >1 >>
<:P_ENV$CHECK_COMMENT .$E <:FILE$GETS .$F #CHARACTER 10 >>
<RETURN <:P_ENV$SCAN .$E >.RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 34 >
<RETURN <ONEOF$MAKE 35 <:STRTAB$GET_STRID <RECORD$GET 10 .$E ><:P_ENV$STRLIT .$E >>>.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 39 >
<RETURN <ONEOF$MAKE 2 <:CHARTAB$GET_CHARID <RECORD$GET 1 .$E ><:P_ENV$CHARLIT .$E >>>.RTN >)(T 
#FALSE () )>
<RETURN <:P_ENV$PUNCT .$E .$C >.RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$SCAN$TYPE O$4869$43$0 >
<PUTPROP :P_ENV SCAN ,:P_ENV$SCAN >
<SET PROCLIST <CONS :P_ENV$IDENT_OR_KEY .PROCLIST>> 

<DEFINE :P_ENV$IDENT_OR_KEY ( $E $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >($C )CHARACTER (VALUE)STRING )
<PROG ($WORD $F )#DECL ( ($WORD )STRING ($F )ANY )

<SET $WORD <STRING$C2S <:LOWER .$C >>>
<SET $F <RECORD$GET 5 .$E >>
<REPEAT () <COND (<AND <APPLYOP :FILE$EOF$TYPE NOT <:FILE$EOF .$F >() ><:IS_ALPHA_OR_NUM <:FILE$PEEK .$F >>>
<PROG ()
<SET $WORD <STRING$APPEND .$WORD <:LOWER <:FILE$GETC .$F >>>>
>) (T <RETURN>)>> 
<RETURN .$WORD .RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$IDENT_OR_KEY$TYPE :STRING >
<PUTPROP :P_ENV IDENT_OR_KEY ,:P_ENV$IDENT_OR_KEY >
<SET PROCLIST <CONS :P_ENV$INTLIT .PROCLIST>> 

<DEFINE :P_ENV$INTLIT ( $E $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >($C )CHARACTER (VALUE)FIX )
<PROG ($I $F )#DECL ( ($I )FIX ($F )ANY )

<SET $I <INT$SUB <CHAR$C2I .$C >48 >>
<SET $F <RECORD$GET 5 .$E >>
<REPEAT () <COND (<AND <APPLYOP :FILE$EOF$TYPE NOT <:FILE$EOF .$F >() ><:IS_NUM <:FILE$PEEK .$F >>>
<PROG ()
<SET $I <INT$SUB <INT$ADD <INT$MUL .$I 10 ><CHAR$C2I <:FILE$GETC .$F >>>48 >>
>) (T <RETURN>)>> 
<RETURN .$I .RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$INTLIT$TYPE :INT >
<PUTPROP :P_ENV INTLIT ,:P_ENV$INTLIT >
<SET PROCLIST <CONS :P_ENV$PUNCT .PROCLIST>> 

<DEFINE :P_ENV$PUNCT ( $E $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >($C )CHARACTER (VALUE)<LIST FIX ANY>)
<PROG ($PC $F $ILL_STR )#DECL ( ($PC )CHARACTER ($F )ANY ($ILL_STR )STRING )

<SET $F <RECORD$GET 5 .$E >>
<COND (<:FILE$EOF .$F >
<SET $PC #CHARACTER 63 >)(T 
<SET $PC <:FILE$PEEK .$F >>)>
<COND (<CHAR$EQUAL .$C #CHARACTER 58 >
<COND (<CHAR$EQUAL .$PC #CHARACTER 61 >
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 1 NIL >.RTN >
>)(T 
<RETURN <ONEOF$MAKE 3 NIL >.RTN >)>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 44 >
<RETURN <ONEOF$MAKE 4 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 91 >
<RETURN <ONEOF$MAKE 20 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 93 >
<RETURN <ONEOF$MAKE 27 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 40 >
<RETURN <ONEOF$MAKE 22 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 41 >
<RETURN <ONEOF$MAKE 29 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 123 >
<RETURN <ONEOF$MAKE 21 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 125 >
<RETURN <ONEOF$MAKE 28 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 59 >
<RETURN <ONEOF$MAKE 31 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 36 >
<RETURN <ONEOF$MAKE 7 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 35 >
<RETURN <ONEOF$MAKE 32 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 33 >
<RETURN <ONEOF$MAKE 13 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 46 >
<RETURN <ONEOF$MAKE 26 NIL >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 43 >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 1 NIL >>.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 45 >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 21 NIL >>.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 61 >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 7 NIL >>.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 38 >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 2 NIL >>.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 124 >
<COND (<CHAR$EQUAL .$PC #CHARACTER 124 >
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 4 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 19 NIL >>.RTN >)>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 42 >
<COND (<CHAR$EQUAL .$PC #CHARACTER 42 >
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 20 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 13 NIL >>.RTN >)>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 47 >
<COND (<CHAR$EQUAL .$PC #CHARACTER 47 >
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 12 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 6 NIL >>.RTN >)>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 60 >
<COND (<CHAR$EQUAL .$PC #CHARACTER 61 >
<PROG ()
<:FILE$ETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 10 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 11 NIL >>.RTN >)>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 62 >
<COND (<CHAR$EQUAL .$PC #CHARACTER 61 >
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 8 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 9 NIL >>.RTN >)>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 126 >
<PROG ()
<COND (<CHAR$EQUAL .$PC #CHARACTER 60 >
<PROG ()
<:FILE$GETC .$F >
<COND (<AND <APPLYOP :FILE$EOF$TYPE NOT <:FILE$EOF .$F >() ><CHAR$EQUAL <:FILE$PEEK .$F >#CHARACTER 61 >>
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 17 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 18 NIL >>.RTN >)>
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$PC #CHARACTER 62 >
<PROG ()
<:FILE$GETC .$F >
<COND (<AND <APPLYOP :FILE$EOF$TYPE NOT <:FILE$EOF .$F >() ><CHAR$EQUAL <:FILE$PEEK .$F >#CHARACTER 61 >>
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 15 NIL >>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 16 NIL >>.RTN >)>
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$PC #CHARACTER 61 >
<PROG ()
<:FILE$GETC .$F >
<RETURN <ONEOF$MAKE 24 <ONEOF$MAKE 14 NIL >>.RTN >
>)(T 
#FALSE () )>
<RETURN <ONEOF$MAKE 23 NIL >.RTN >
>)(T 
#FALSE () )>
<SET $ILL_STR <STRING$C2S .$C >>
<REPEAT () <COND (<APPLYOP :COR$TYPE NOT <OR <:FILE$EOF .$F ><:IS_LEGAL <:FILE$PEEK .$F >>>() >
<PROG ()
<SET $ILL_STR <STRING$APPEND .$ILL_STR <:FILE$GETC .$F >>>
>) (T <RETURN>)>> 
<:P_ENV$BAD .$E .$ILL_STR "Illegal characters in text">
<RETURN <:P_ENV$SCAN .$E >.RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$PUNCT$TYPE O$4869$43$0 >
<PUTPROP :P_ENV PUNCT ,:P_ENV$PUNCT >
<SET PROCLIST <CONS :P_ENV$STRLIT .PROCLIST>> 

<DEFINE :P_ENV$STRLIT ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >(VALUE)STRING )
<PROG ($NS $F )#DECL ( ($NS )STRING ($F )ANY )

<SET $NS "">
<SET $F <RECORD$GET 5 .$E >>
<REPEAT () <COND (<APPLYOP :FILE$EOF$TYPE NOT <:FILE$EOF .$F >() >
<PROG ($C )#DECL ( ($C )CHARACTER )
<SET $C <:FILE$GETC .$F >>
<COND (<CHAR$EQUAL .$C #CHARACTER 34 >
<RETURN .$NS .RTN >)(T 
#FALSE () )>
<COND (<APPLYOP :IS_PRINTING$TYPE NOT <:IS_PRINTING .$C >() >
<PROG ()
<:P_ENV$BAD .$E .$NS "Illegal character in string literal">
<COND (<CHAR$EQUAL .$C #CHARACTER 10 >
<PROG ()
<RECORD$PUT 7 .$E <INT$ADD <RECORD$GET 7 .$E >1 >>
<RETURN .$NS .RTN >
>)(T 
#FALSE () )>
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 92 >
<SET $NS <STRING$APPEND .$NS <:P_ENV$ESCAPE .$E >>>)(T 
<SET $NS <STRING$APPEND .$NS .$C >>)>
>) (T <RETURN>)>> 
<:P_ENV$BAD .$E .$NS "Unterminated string literal">
<RETURN .$NS .RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$STRLIT$TYPE :STRING >
<PUTPROP :P_ENV STRLIT ,:P_ENV$STRLIT >
<SET PROCLIST <CONS :P_ENV$CHARLIT .PROCLIST>> 

<DEFINE :P_ENV$CHARLIT ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >(VALUE)CHARACTER )
<PROG ($F $C )#DECL ( ($F )ANY ($C )CHARACTER )

<SET $F <RECORD$GET 5 .$E >>
<COND (<:FILE$EOF .$F >
<PROG ()
<:P_ENV$BAD .$E """Unterminated character literal">
<RETURN #CHARACTER 63 .RTN >
>)(T 
#FALSE () )>
<SET $C <:FILE$GETC .$F >>
<COND (<APPLYOP :IS_PRINTING$TYPE NOT <:IS_PRINTING .$C >() >
<PROG ()
<:P_ENV$BAD .$E """Illegal character in character literal">
<COND (<CHAR$EQUAL .$C #CHARACTER 10 >
<PROG ()
<RECORD$PUT 7 .$E <INT$ADD <RECORD$GET 7 .$E >1 >>
<RETURN #CHARACTER 63 .RTN >
>)(T 
#FALSE () )>
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 39 >
<PROG ()
<:P_ENV$BAD .$E """Empty character literal">
<RETURN #CHARACTER 63 .RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 92 >
<SET $C <:P_ENV$ESCAPE .$E >>)(T 
#FALSE () )>
<COND (<OR <:FILE$EOF .$F ><NOT <CHAR$EQUAL <:FILE$PEEK .$F >#CHARACTER 39 >>>
<:P_ENV$BAD .$E <STRING$C2S .$C >"Unterminated character literal">)(T 
<:FILE$GETC .$F >)>
<RETURN .$C .RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$CHARLIT$TYPE :CHAR >
<PUTPROP :P_ENV CHARLIT ,:P_ENV$CHARLIT >
<SET PROCLIST <CONS :P_ENV$ESCAPE .PROCLIST>> 

<DEFINE :P_ENV$ESCAPE ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >(VALUE)CHARACTER )
<PROG ($F $OS $C $J )#DECL ( ($F )ANY ($OS )STRING ($C )CHARACTER ($J )FIX )

<SET $F <RECORD$GET 5 .$E >>
<SET $OS "\\">
<COND (<:FILE$EOF .$F >
<PROG ()
<:P_ENV$BAD .$E .$OS "Illegal escape sequence">
<RETURN #CHARACTER 63 .RTN >
>)(T 
#FALSE () )>
<SET $C <:FILE$PEEK .$F >>
<COND (<CHAR$EQUAL .$C #CHARACTER 110 >
<PROG ()
<:FILE$GETC .$F >
<RETURN #CHARACTER 10 .RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 116 >
<PROG ()
<:FILE$GETC .$F >
<RETURN #CHARACTER 9 .RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 39 >
<RETURN <:FILE$GETC .$F >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 34 >
<RETURN <:FILE$GETC .$F >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 92 >
<RETURN <:FILE$GETC .$F >.RTN >)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 98 >
<PROG ()
<:FILE$GETC .$F >
<RETURN #CHARACTER 8 .RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 112 >
<PROG ()
<:FILE$GETC .$F >
<RETURN #CHARACTER 12 .RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 114 >
<PROG ()
<:FILE$GETC .$F >
<RETURN #CHARACTER 13 .RTN >
>)(T 
#FALSE () )>
<COND (<CHAR$EQUAL .$C #CHARACTER 118 >
<PROG ()
<:FILE$GETC .$F >
<RETURN #CHARACTER 11 .RTN >
>)(T 
#FALSE () )>
<SET $J 0 >
<PROG ($I K I)#DECL (($I K I)FIX)<SET I 1 ><SET K 3 ><SET $I .I><REPEAT () <COND (<L? .K .$I > <RETURN>)> 
<PROG ()
<COND (<OR <:FILE$EOF .$F ><APPLYOP :IS_OCTAL$TYPE NOT <:IS_OCTAL <:FILE$PEEK .$F >>() >>
<PROG ()
<:P_ENV$BAD .$E .$OS "Illegal escape sequence">
<RETURN #CHARACTER 63 .RTN >
>)(T 
#FALSE () )>
<SET $C <:FILE$GETC .$F >>
<SET $OS <STRING$APPEND .$OS .$C >>
<SET $J <INT$SUB <INT$ADD <INT$MUL .$J 8 ><CHAR$C2I .$C >>48 >>
><SET $I <+ 1 .$I >>>>
<RETURN <CHAR$I2C .$J >.RTN >
><:RETURN-ERROR>>
<SETG :P_ENV$ESCAPE$TYPE :CHAR >
<PUTPROP :P_ENV ESCAPE ,:P_ENV$ESCAPE >
<SET PROCLIST <CONS :P_ENV$BAD .PROCLIST>> 

<DEFINE :P_ENV$BAD ( $E $TEXT $WHY  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >($TEXT )STRING ($WHY )STRING )
<PROG ($F )#DECL ( ($F )ANY )

<SET $F <RECORD$GET 2 .$E >>
<:FILE$PUTI .$F <RECORD$GET 7 .$E >>
<:FILE$PUTS .$F <STRING$CONCAT <STRING$CONCAT <STRING$CONCAT ":	".$WHY >": ">.$TEXT >>
<:FILE$PUTC .$F #CHARACTER 10 >
<COND (<INT$GT 1 <RECORD$GET 3 .$E >>
<RECORD$PUT 3 .$E 1 >)(T 
#FALSE () )>
>DONE >
<PUTPROP :P_ENV BAD ,:P_ENV$BAD >
<SET PROCLIST <CONS :P_ENV$CHECK_COMMENT .PROCLIST>> 

<DEFINE :P_ENV$CHECK_COMMENT ( $E $COMMENT  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )<VECTOR ANY ANY FIX ANY ANY ANY FIX <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>ANY ANY ANY >($COMMENT )STRING )
<PROG ()

<PROG ($I K I)#DECL (($I K I)FIX)<SET I 1 ><SET K <STRING$SIZE .$COMMENT >><SET $I .I><REPEAT () <COND (<L? .K .$I > <RETURN>)> 
<PROG ($C )#DECL ( ($C )CHARACTER )
<SET $C <STRING$FETCH .$COMMENT .$I >>
<COND (<APPLYOP :COR$TYPE NOT <OR <:IS_PRINTING .$C ><CHAR$EQUAL .$C #CHARACTER 9 >>() >
<PROG ()
<:P_ENV$BAD .$E "comment has illegal chars".$COMMENT >
<RETURN DONE .RTN >
>)(T 
#FALSE () )>
><SET $I <+ 1 .$I >>>>
>DONE >
<PUTPROP :P_ENV CHECK_COMMENT ,:P_ENV$CHECK_COMMENT >
<SETG :P_ENV(:P_ENV)>
<SET PROCLIST <CONS :IS_ALPHA .PROCLIST>> 

<DEFINE :IS_ALPHA ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <OR <AND <CHAR$GE .$C #CHARACTER 97 ><CHAR$LE .$C #CHARACTER 122 >><CHAR$EQUAL .$C #CHARACTER 95 ><AND <CHAR$GE .$C #CHARACTER 65 ><CHAR$LE .$C #CHARACTER 90 >>>.RTN >
><:RETURN-ERROR>>
<SETG :IS_ALPHA$TYPE :BOOL >
<SET PROCLIST <CONS :IS_NUM .PROCLIST>> 

<DEFINE :IS_NUM ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <AND <CHAR$GE .$C #CHARACTER 48 ><CHAR$LE .$C #CHARACTER 57 >>.RTN >
><:RETURN-ERROR>>
<SETG :IS_NUM$TYPE :BOOL >
<SET PROCLIST <CONS :IS_ALPHA_OR_NUM .PROCLIST>> 

<DEFINE :IS_ALPHA_OR_NUM ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <OR <:IS_ALPHA .$C ><:IS_NUM .$C >>.RTN >
><:RETURN-ERROR>>
<SETG :IS_ALPHA_OR_NUM$TYPE :BOOL >
<SET PROCLIST <CONS :IS_FORMAT .PROCLIST>> 

<DEFINE :IS_FORMAT ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <OR <CHAR$EQUAL .$C #CHARACTER 32 ><AND <CHAR$GE .$C #CHARACTER 9 ><CHAR$LE .$C #CHARACTER 13 >>>.RTN >
><:RETURN-ERROR>>
<SETG :IS_FORMAT$TYPE :BOOL >
<SET PROCLIST <CONS :IS_PRINTING .PROCLIST>> 

<DEFINE :IS_PRINTING ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <AND <CHAR$GE .$C #CHARACTER 32 ><CHAR$LE .$C #CHARACTER 126 >>.RTN >
><:RETURN-ERROR>>
<SETG :IS_PRINTING$TYPE :BOOL >
<SET PROCLIST <CONS :LOWER .PROCLIST>> 

<DEFINE :LOWER ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)CHARACTER )
<PROG ()

<COND (<AND <CHAR$GE .$C #CHARACTER 65 ><CHAR$LE .$C #CHARACTER 90 >>
<RETURN <CHAR$I2C <INT$ADD <CHAR$C2I .$C >32 >>.RTN >)(T 
<RETURN .$C .RTN >)>
><:RETURN-ERROR>>
<SETG :LOWER$TYPE :CHAR >
<SET PROCLIST <CONS :IS_OCTAL .PROCLIST>> 

<DEFINE :IS_OCTAL ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <AND <CHAR$GE .$C #CHARACTER 48 ><CHAR$LE .$C #CHARACTER 55 >>.RTN >
><:RETURN-ERROR>>
<SETG :IS_OCTAL$TYPE :BOOL >
<SET PROCLIST <CONS :IS_LEGAL .PROCLIST>> 

<DEFINE :IS_LEGAL ( $C  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($C )CHARACTER (VALUE)<OR ATOM FALSE>)
<PROG ()

<RETURN <OR <:IS_FORMAT .$C ><AND <CHAR$GE .$C #CHARACTER 32 ><INT$EQUAL <STRING$INDEXC .$C "?@^`">0 >>>.RTN >
><:RETURN-ERROR>>
<SETG :IS_LEGAL$TYPE :BOOL >
<SET PROCLIST <CONS :PT_TOKEN .PROCLIST>> 

<DEFINE :PT_TOKEN ( $K $F  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($K )<LIST FIX ANY>($F )ANY )
<PROG ($S )#DECL ( ($S )STRING )

<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 18 >
<PROG ()
<:PT_INTID .$K .$F >
<RETURN DONE .RTN >
>)
(<==? .TG 2 >
<PROG ()

<:PT_CHARID .$K .$F >
<RETURN DONE .RTN >
>)
(<==? .TG 35 >
<PROG ()

<:PT_STRID .$K .$F >
<RETURN DONE .RTN >
>)
(<==? .TG 16 >
<SET $S <:IDENT$GET_STR .$K >>)
(<==? .TG 24 >
<PROG ()
<:PT_INFIXOP .$K .$F >
<RETURN DONE .RTN >
>)
(<==? .TG 23 >
<SET $S "~">)
(<==? .TG 1 >
<SET $S ":=">)
(<==? .TG 3 >
<SET $S ":">)
(<==? .TG 4 >
<SET $S ",">)
(<==? .TG 31 >
<SET $S ";">)
(<==? .TG 7 >
<SET $S "$">)
(<==? .TG 26 >
<SET $S ".">)
(<==? .TG 32 >
<SET $S "#">)
(<==? .TG 13 >
<SET $S "!">)
(<==? .TG 22 >
<SET $S "(">)
(<==? .TG 20 >
<SET $S "[">)
(<==? .TG 21 >
<SET $S "{">)
(<==? .TG 29 >
<SET $S ")">)
(<==? .TG 27 >
<SET $S "]">)
(<==? .TG 28 >
<SET $S "}">)
(<==? .TG 40 >
<SET $S <:TYPEKEY_STRING .$K >>)
(<==? .TG 14 >
<SET $S <:EXPRKEY_STRING .$K >>)
(<==? .TG 34 >
<SET $S <:STMTKEY_STRING .$K >>)
(<==? .TG 5 >
<SET $S <:DEFNKEY_STRING .$K >>)
(<==? .TG 6 >
<SET $S "DO">)
(<==? .TG 10 >
<SET $S "END">)
(<==? .TG 38 >
<SET $S "THEN">)
(<==? .TG 9 >
<SET $S "ELSEIF">)
(<==? .TG 8 >
<SET $S "ELSE">)
(<==? .TG 37 >
<SET $S "TAG">)
(<==? .TG 17 >
<SET $S "IN">)
(<==? .TG 25 >
<SET $S "OTHERS">)
(<==? .TG 12 >
<SET $S "EXCEPT">)
(<==? .TG 41 >
<SET $S "WHEN">)
(<==? .TG 30 >
<SET $S "RETURNS">)
(<==? .TG 33 >
<SET $S "SIGNALS">)
(<==? .TG 43 >
<SET $S "YIELDS">)
(<==? .TG 42 >
<SET $S "WHERE">)
(<==? .TG 19 >
<SET $S "IS">)
(<==? .TG 15 >
<SET $S "HAS">)
(<==? .TG 39 >
<SET $S "TO">)
(<==? .TG 11 >
<RETURN DONE .RTN >)>>>
<:FILE$PUTS .$F .$S >
>DONE >
<SET PROCLIST <CONS :TYPEKEY_STRING .PROCLIST>> 

<DEFINE :TYPEKEY_STRING ( $K  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($K )<LIST FIX ANY>(VALUE)STRING )
<PROG ($S )#DECL ( ($S )STRING )

<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 3 >
<SET $S "BOOL">)
(<==? .TG 6 >
<SET $S "INT">)
(<==? .TG 13 >
<SET $S "STRING">)
(<==? .TG 4 >
<SET $S "CHAR">)
(<==? .TG 8 >
<SET $S "NULL">)
(<==? .TG 14 >
<SET $S "TYPE">)
(<==? .TG 1 >
<SET $S "ANY">)
(<==? .TG 5 >
<SET $S "CVT">)
(<==? .TG 12 >
<SET $S "REP">)
(<==? .TG 2 >
<SET $S "ARRAY">)
(<==? .TG 11 >
<SET $S "RECORD">)
(<==? .TG 9 >
<SET $S "ONEOF">)
(<==? .TG 10 >
<SET $S "PROCTYPE">)
(<==? .TG 7 >
<SET $S "ITERTYPE">)>>>
<RETURN .$S .RTN >
><:RETURN-ERROR>>
<SETG :TYPEKEY_STRING$TYPE :STRING >
<SET PROCLIST <CONS :EXPRKEY_STRING .PROCLIST>> 

<DEFINE :EXPRKEY_STRING ( $K  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($K )<LIST FIX ANY>(VALUE)STRING )
<PROG ($S )#DECL ( ($S )STRING )

<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 4 >
<SET $S "NIL">)
(<==? .TG 5 >
<SET $S "TRUE">)
(<==? .TG 2 >
<SET $S "FALSE">)
(<==? .TG 3 >
<SET $S "FORCE">)
(<==? .TG 6 >
<SET $S "UP">)
(<==? .TG 1 >
<SET $S "DOWN">)>>>
<RETURN .$S .RTN >
><:RETURN-ERROR>>
<SETG :EXPRKEY_STRING$TYPE :STRING >
<SET PROCLIST <CONS :STMTKEY_STRING .PROCLIST>> 

<DEFINE :STMTKEY_STRING ( $K  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($K )<LIST FIX ANY>(VALUE)STRING )
<PROG ($S )#DECL ( ($S )STRING )

<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 4 >
<SET $S "IF">)
(<==? .TG 3 >
<SET $S "FOR">)
(<==? .TG 7 >
<SET $S "TAGCASE">)
(<==? .TG 8 >
<SET $S "WHILE">)
(<==? .TG 5 >
<SET $S "RETURN">)
(<==? .TG 9 >
<SET $S "YIELD">)
(<==? .TG 6 >
<SET $S "SIGNAL">)
(<==? .TG 2 >
<SET $S "BREAK">)
(<==? .TG 1 >
<SET $S "BEGIN">)>>>
<RETURN .$S .RTN >
><:RETURN-ERROR>>
<SETG :STMTKEY_STRING$TYPE :STRING >
<SET PROCLIST <CONS :DEFNKEY_STRING .PROCLIST>> 

<DEFINE :DEFNKEY_STRING ( $K  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($K )<LIST FIX ANY>(VALUE)STRING )
<PROG ($S )#DECL ( ($S )STRING )

<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 3 >
<SET $S "PROC">)
(<==? .TG 2 >
<SET $S "ITER">)
(<==? .TG 1 >
<SET $S "CLUSTER">)>>>
<RETURN .$S .RTN >
><:RETURN-ERROR>>
<SETG :DEFNKEY_STRING$TYPE :STRING >
<SETG O$4869$3$0'(:ONEOF :NULL :NULL :NULL )>
<SETG O$4869$6$0'(:ONEOF :NULL :NULL :NULL :NULL :NULL :NULL )>
<SETG O$4869$9$0'(:ONEOF :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL )>
<SETG O$4869$14$0'(:ONEOF :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL )>
<SETG O$4869$21$0'(:ONEOF :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL )>
<SETG O$4869$43$0'(:ONEOF :NULL :CHARID :NULL :NULL O$4869$3$0 :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL O$4869$6$0 :NULL :IDENT :NULL :INTID :NULL :NULL :NULL :NULL :NULL O$4869$21$0 :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL :NULL O$4869$9$0 :IDENT :IDENT :NULL :NULL :NULL O$4869$14$0 :NULL :NULL :NUL