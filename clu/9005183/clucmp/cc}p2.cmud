*UJ PC$̋Ha
*UH/ck۷A]2m
*UHCE<HB?AÙ4>AAÙ4 Q/AÙ4 ysSAT/P.S̓u>A񢆊ycIPSYAEAΉOg΃(3LT(S(NQ q"Ù
(I($3 Sl QfU/+E yaԟH*֋u'Al 6FVu'AéF#I}FyA	"ѫ5"AMh Q
EjE
^Vu'AéF#I}	)ԛ)yaԟH*֋u'Al 6F:͓EAE<uέ׿kEEAE<$5`ԋh:hՃfI$AMh:MiA"]Ή_ՒPE.IԫS[]hՃi]Mh.>O:*ҝiROԏ_,4"8o0AE<PIC:MiA)Oi}O"E3uԛ$ө
$	%ɝ"$ϝ3 QgDQ*P"3bAU')HE QP)P(IrgDA1A̫^Vu'AéF#I}#E<SQMh Q
S)SéUOAl 6)CE<$jSAiR)!ҋ5"cЋ5(S!ϝTAP(I0IKA(E QaSA/&I#IgY}	& Sl Q)yiAl _)O)ũ	& yT/ŝ#ũ$΋.I>O)ũ	%yT/ŝ#ũ"ŗ'ˋ$)O
'̉lAq"Ù
OS&I#IgY}(S'̉l]>yA#IhGaA
*GSS)ũ#y$ ]"G(}A<.#ճ>AΉE(y_]3iyA
FyT/ŝ'EO.I)O
'̉lAq"Ù
OS&I#IgY}(S'̉l]>yA#IhGaA
*GSS)ũ#y$ ]"G(}A<.#ճ>AΉE(y_]4AE<$T<uA"}FQ^A#gyqj I0yT/ƟH$)J={T>O)ũ	 §PcÃqP.I>S<{. }SAh:I$)J={TP>O)ũ	 §'΋MqP1cPlPiA">S<{.}SAhO$2c:"ءS$өEA>}#E(y_]6AE<$T<uɏf ]P>}#E(y_]2AE<$T<gIeA'I)J={TP>O(R)O)ũ	 §'΋MqP3A_,]P3Aϟ_.IE4AQcɝ˗E_>})J={T[ }P(I)GaA$h4 6A/A%yT/ŝ(Eh$>}P(#ճ(ċs(Q"G*P<4 6A/yqj #ճTP(T
P# Q#Al)AA<.#ճ_>yqj I<.#ճ>AΉE(y<{. }^A#c={T>}SAh:"Ù_t ]P>}#E(y_]2iyADTGaA
'̉lA$өA3S)ũDP.I>yA#I)Aq"Ù
T(#I(S*GAHADP1})ũ	*KAHADP2}CGA)O
T Q
T4 6A/A%A_ՒP.I}E<SQ"G*P# QDTyiAl _)AA"G($s>yA#I SE(PF
P<T'T̉lcϞSTNOAO ysDA<{.}RiNA)ԛ.>Sq̧)A/>OP$T.IezeyzsA8azwgA;( }:hՃfI$yqj I0yύ`ˋN>OE<$T<uءWԛ$)}ϔE<$T<uءWԛ$)}φ}#E(y<{.AGAH<{.AGA>y_]1iAaSA_)_j ]P>}#E(y<{.4AGAL>y_]2e)O
_ՒEH$Xzo Qas-Aysa|pLP>O)ũ	 §P(Ru&A"}E>SΉ
:Ήoө.I$3 }SAhO$2eAϔE<*ҝS)]U' }/}E<TI1"HA)ԛ<u؇* ]P<uu&It$T.I>})A<*ҝ_>A<uQjUbҥ>O)ũPu&ԙ4$4"QPiR(S)}S(Rs$ө!ϝhP1.S̓u>A񢆊ycIP1(AP E*If"A ΉiSA
TEfENSċs(A	"S3QfU/&I#IgY}#E<SQiM	$Ƨ	 §
Qċs(A	 қhOkE 6F#IIhO+E aԟH#IAl>yiAl _>QaSA/&I#IgY}#EAiM ҥ6RCjEA(>O)ũ	$Ƨ$Siyύ`ˋN]}SAhO$2sIh>O)Ej Q(C(E<SQ$	!O
Qċs(A	, S3Q)yiAl _(IS Sé<OkE 6F#I+E aԟH#IAl>}#E<$P(RA"aA<uέԿb˿ŝEAφyADTGaA
'̉lA$өA3S)ũDP.Ih<SQ$
P# Q#Al)AA<.#ճ_>yqj IhNOAO ysDA<{.AE<uέة'ˋ$E<uέiӫP.ITi|p$EO}E<$<uO($>}APl$ ]iM$.I.O)ũ	%yT/ŝ#ũ"ŗ'ˋ$)O
'̉lAq"Ù
OS&I#IgY}(S'̉l]>yA#IhGaA
*GSS)ũ#y$ ]"G(}A<.#ճ>AΉE(y_]9AE<uέة'ˋ$GA)O
_ՒN/ԟqg ]P>O)E$2A$Ƨ'΋MqP1A_,]P3Aϟ_.IE4A1.]"}RiNA §T}#E(y_]1ayA
FyT/ŝ'EO.IԫS.I0]U' })QyA
FyT/ŝ ӧb]P"ic.]gDEE<*ҝAhR_>})A<*ҝ_>A<uQjUbҥ>O)ũP1TPOI7I-0AE<PIC:A)Oi}O"E3uO
$Og΃(3LT(S(NQ q"Ù
(I(VbyiAl _)O(R$4IhC$)GaA$4S$өA3Q)yiAl _(IpfLA/+E P<OkE 6F#I&I#IgY}BO+E aԟH#IAl>yaԟH*֋u'Al 6F)CE<uέ׿kEEAE<$P$/Ћԟqg ]P>}P(#ճ(ċs(Q"G*P<4 6A/yqj #ճKA(RT	%SE(PF
P<T'T̉lcϞSKAHADP2}CGA->O)ũ	+AhO$2e ҥ6RCjEA(>}** O)ũ	+Ah:bN_SA"}_>}SKA_ՒGEwO.I>O(ROSE(#ճ(LuF γP<OA%})O
*GA)Aq"Ù
T(#I(S*GAHADP1})ũ	%y$ ]"G(>}!ϝQ^A#c_ՒN/ԟqg ]P>S_ՒAufA"E3i]ˤ]ˢΉO}E<$3& yT/̓qoɝA"yT/ű.I }φyqj IS yT/ğEAφyT/ŝ(O"֋$yQjUO$2q$.IpfLA+Ah.]U' }<uQjUbҥ>O)ũP$4"8o[$ayqj S̓u<uOA)Oi}O"E3uOAEAЩ3AHH&Eh)SARFGaA$
`γ
+ATO+E aԟH#IAl>yaԟH*֋u'Al 6F)O(R$	!O
Qċs(A	%S$өA3QA/+E yaԟH*֋u'Al 6FVu'AéF#I}FO)ũ	%yT/ŝ#ũ"ŗ'ˋ$)O
'̉lAq"Ù
OS&I#IgY}(S'̉l]>yA#IhGaA
*GSS)ũ#y$ ]"G(}A<.#ճ>AΉE(y_]6AE<uέة'ˋ$E<uέiӫP.IDw .>SϟAA_,]P3AφyT/ŝ$Ήw .>O)E ]AԪNAE>yTԫSťS>}S:'4"8o0AE<PIC:bN_SA)Oi}O"E3uĝwҿa̧
$Og΃(3LT(S(NQ q"Ù
(I(VbyiAl _)O(R$	$ĝhKA(E Q)6(I1'SA/+E aԟH#IAl>Q)yiAl _)CE<$P$/̓gOA"}E<$yT/ɉ$өEAφyqj Ih:gVIj_eߩA"}E<SQ"G*P# QDTyiAl _)AA"G($P(KA(ċs(QԠ6yqj NOA/<$'T̉leϐ< J={T>O(R$	"E$h Q
TA0gYA	"E)yaԟH*֋u'Al 6F$h4 6A/_ՒN/ԟqg ]P>O)ũ	* yT/ԳP.I>O)ũ	*KA_ՒGEwO.I>O(ROSE(#ճ(LuF γP<OA*KA(RT	*KA(ċs(QԠ6yqj NOA/<$hNOAO ysDA<{. }P(S:gVIlTŝEAE<$SA_Lu.I>OE<$SAiR)!ҋ5"c)}φy4AbDDs)$ĝh$_iR))ũ'A"E1AE<*ҝ'΋MqP1A"E>]U' })QyQjUO$2eI>]U' }/>O:*ҝiROԏ_ߟWETPOI7II }S(Rs$ө!ϝhP1'Lu.S̓u>A񢆊ycIP1'Lu(AP E*If"A ΉiSA
TEfENSċs(A	"S3QfU/+E aԟH#IAl>SP(I1'SA(E QbN
^Vu'AéF#I}#EAbN ҥ6RCjEA(>O)Ej Q(C(E<SQ)GaA$
^LuF γFy4AbDI<uĝEAφyqj Ih:gVIj_eߩA"}E<SQ"G*P# QDTyiAl _)AA"G($P(KA(ċs(QԠ6yqj NOA/<$'T̉leϐ< J={T>OP$*_A"}** O)E ]bNT}E>S
* yQjUϔ}E>yTԫSťS>}S:bN4$4"QPiR(IO)ũ)OiAΧ_.S̓u>A񢆊ycIP1' Q	"ASTE
$A"ҧ
AS͋H)T#E# Q
EA0gYA̫`γ
FyA	%Sq"Ù
(Ih4 6A/SKA_ՒGEwO.I>O(ROSE(#ճ(LuF γP<OA%})O
*GA)Aq"Ù
T(#I(S*GAHADP1})ũ	%y$ ]"G(>}!ϝQ^A#c)O
_ՒN/ԟqg ]P>O)E yT/ŝ#ũbNA"]>]U' })QyA
FyT/ŝ ӧb]P">O)E yT/ŝ'EbNA"ErnOR_>}<uQjUbҥ>O)ũP1'$4"u1' }S(Rs$ө!ϝhPa̙4 ]Ù4>}E"ƓP:"ÙiAEAЩ3AHH&Eh)SARFGaA$
`γ
+ATOkE 6F#IFyA	"E)GaA$SA/+E aԟH#IAl>S񢆊yqj Ia̧ ҥ6RCjEA(>O)Ej Q(C(E<SQ)GaA$
^LuF γFy4AbDDs)yT/ċs.I>O)ũ	%yT/ŝ#ũ"ŗ'ˋ$)O
'̉lAq"Ù
OS&I#IgY}(S'̉l]>yA#IhGaA
*GSS)ũ#y$ ]"G(}A<.#ճ>AΉE(y_]4AE<uέة'ˋ$E<*ҝDs)]U' }/>OQRiN}/ O:*ҝiROԏ_LuTP(u4A4q2IHO)ũ)OiAΧ_ ]Ù4>}E"ƓP:"Ù
$Og΃(3LT(S(NQ q"Ù
(I(VbyaԟHVu'AéF#I}3}#E<SQ$IKA(E Q$IDNS )<VECTOR UVECTOR FIX FIX FIX>($T )ANY ($K )<LIST FIX ANY>)CE<ET $IDNS <:P_IDNLIST .$E >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 3 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<SET $T <:P_TYPE .$E >>
>)(T 
<PROG ()
<:P_ENV$ASSUME .$E ": type in decl">
<SET $T <:P_ENV$GET_UNKNOWN_TYPE .$E >>
>)>>>
<RETURN [.$IDNS .$T ].RTN >
><:RETURN-ERROR>>
<SETG :P_DECL$TYPE R$4887$2$2 >
<SET PROCLIST <CONS :P_TAGCASE .PROCLIST>> 

<DEFINE :P_TAGCASE ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($ARMS $OBJ $TST $ABS )#DECL ( ($ARMS )<VECTOR UVECTOR FIX FIX FIX>($OBJ )ANY ($TST )<VECTOR <VECTOR UVECTOR FIX FIX FIX>ANY <LIST FIX ANY>>($ABS )<LIST FIX ANY>)

<SET $ARMS <ARRAY$CREATE 1 >>
<SET $OBJ <:P_EXPR .$E 0 >>
<SET $TST [.$ARMS .$OBJ <ONEOF$MAKE 2 NIL >]>
<SET $ABS <ONEOF$MAKE 14 .$TST >>
<REPEAT () <COND (T 
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 37 >
<PROG ($TAGS $VAR $BOD )#DECL ( ($TAGS )<VECTOR UVECTOR FIX FIX FIX>($VAR )<LIST FIX ANY>($BOD )<VECTOR <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>>)
<:P_ENV$NEXT_TOKEN .$E >
<:P_ENV$NEW_LEVEL .$E >
<SET $TAGS <:P_NAMELIST .$E >>
<SET $VAR <:P_MDECL .$E >>
<SET $BOD <:P_CBODY .$E 1 ": in TAG...: body">>
<ARRAY$ADDH .$ARMS [.$BOD .$TAGS .$VAR ]>
<:P_ENV$POP_LEVEL .$E >
>)
(<==? .TG 25 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RECORD$PUT 3 .$TST <:P_CBODY .$E 3 ": in OTHERS: body">>
<:P_END .$E "END in TAGCASE...END">
<RETURN .$ABS .RTN >
>)
(<==? .TG 10 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<RETURN .$ABS .RTN >
>)(T 
<PROG ()
<:P_ENV$ASSUME .$E "END in TAGCASE...END">
<RETURN .$ABS .RTN >
>)>>>
>) (T <RETURN>)>> 
><:RETURN-ERROR>>
<SETG :P_TAGCASE$TYPE O$4887$16$0 >
<SET PROCLIST <CONS :P_WHILE .PROCLIST>> 

<DEFINE :P_WHILE ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($TEST $BOD )#DECL ( ($TEST )ANY ($BOD )<VECTOR <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>>)

<SET $TEST <:P_EXPR .$E 0 >>
<SET $BOD <:P_DO .$E >>
<RETURN <ONEOF$MAKE 15 [.$BOD .$TEST ]>.RTN >
><:RETURN-ERROR>>
<SETG :P_WHILE$TYPE O$4887$16$0 >
<SET PROCLIST <CONS :P_SIGNAL .PROCLIST>> 

<DEFINE :P_SIGNAL ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($N $ARGS )#DECL ( ($N )ANY ($ARGS )<VECTOR UVECTOR FIX FIX FIX>)

<SET $N <:P_NAME .$E >>
<SET $ARGS <:P_PEXPRLIST .$E T >>
<RETURN <ONEOF$MAKE 12 [.$ARGS .$N ]>.RTN >
><:RETURN-ERROR>>
<SETG :P_SIGNAL$TYPE O$4887$16$0 >
<SET PROCLIST <CONS :P_DECL_OR_ASSN .PROCLIST>> 

<DEFINE :P_DECL_OR_ASSN ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($VARS $K )#DECL ( ($VARS )<LIST FIX ANY>($K )<LIST FIX ANY>)

<SET $VARS <:P_IDNS_OR_DECLS .$E >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 1 >
<PROG ($EL )#DECL ( ($EL )<VECTOR UVECTOR FIX FIX FIX>)
<:P_ENV$NEXT_TOKEN .$E >
<SET $EL <:P_EXPRLIST .$E #FALSE () >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$VARS ><PROG (TG $VARS ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $VARS <NTH .OLDGUY 2>> <COND 
(<==? .TG 2 >
<RETURN <ONEOF$MAKE 1 [.$VARS .$EL ]>.RTN >)
(<==? .TG 1 >
<PROG ($X )#DECL ( ($X )ANY )
<COND (<INT$EQUAL <ARRAY$SIZE .$EL >1 >
<SET $X <ARRAY$BOTTOM .$EL >>)(T 
<PROG ()
<:P_ENV$ERR .$E "only 1 expr allowed in declinit"1 >
<SET $X <:P_ENV$GET_BAD_EXPR .$E >>
>)>
<RETURN <ONEOF$MAKE 6 [.$VARS .$X ]>.RTN >
>)>>>
>)(T 
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$VARS ><PROG (TG $VARS ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $VARS <NTH .OLDGUY 2>> <COND 
(<==? .TG 2 >
<PROG ()
<:P_ENV$ASSUME .$E ": type in decl">
<RETURN <ONEOF$MAKE 5 [<:P_ENV$GET_UNKNOWN_TYPE .$E >.$VARS ]>.RTN >
>)
(<==? .TG 1 >
<COND (<INT$EQUAL <ARRAY$SIZE .$VARS >1 >
<RETURN <ONEOF$MAKE 5 <ARRAY$BOTTOM .$VARS >>.RTN >)(T 
<PROG ()
<:P_ENV$ASSUME .$E ":= invoke in declinit">
<RETURN <ONEOF$MAKE 6 [.$VARS <:P_ENV$GET_BAD_EXPR .$E >]>.RTN >
>)>)>>>)>>>
><:RETURN-ERROR>>
<SETG :P_DECL_OR_ASSN$TYPE O$4887$16$0 >
<SET PROCLIST <CONS :P_EXPR_STMT .PROCLIST>> 

<DEFINE :P_EXPR_STMT ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($X $K )#DECL ( ($X )ANY ($K )<LIST FIX ANY>)

<SET $X <:P_EXPR .$E 0 >>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 1 >
<PROG ($RIGHT )#DECL ( ($RIGHT )ANY )
<:P_ENV$NEXT_TOKEN .$E >
<SET $RIGHT <:P_EXPR .$E 0 >>
<RETURN <ONEOF$MAKE 13 [.$X .$RIGHT ]>.RTN >
>)(T 
<RETURN <ONEOF$MAKE 10 <:P_MAKE_INVOKE .$E .$X >>.RTN >)>>>
><:RETURN-ERROR>>
<SETG :P_EXPR_STMT$TYPE O$4887$16$0 >
<SET PROCLIST <CONS :P_MAKE_INVOKE .PROCLIST>> 

<DEFINE :P_MAKE_INVOKE ( $E $X  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($X )ANY (VALUE)<VECTOR ANY <VECTOR UVECTOR FIX FIX FIX><LIST FIX ANY>>)
<PROG ($ABS )#DECL ( ($ABS )<LIST FIX ANY>)

<SET $ABS <:EXPR$GET_ABS .$X >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$ABS ><PROG (TG $ABS ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $ABS <NTH .OLDGUY 2>> <COND 
(<==? .TG 13 >
<RETURN .$ABS .RTN >)(T 
<PROG ()
<:P_ENV$ERR .$E "preceding expr is not an invoke"1 >
<RETURN [<:P_ENV$GET_BAD_EXPR .$E ><ARRAY$CREATE 1 ><ONEOF$MAKE 3 NIL >].RTN >
>)>>>
><:RETURN-ERROR>>
<SETG :P_MAKE_INVOKE$TYPE R$4887$3$3 >
<SET PROCLIST <CONS :P_EXCEPT .PROCLIST>> 

<DEFINE :P_EXCEPT ( $E $ST  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($ST )ANY (VALUE)ANY )
<PROG ()

<REPEAT () <COND (T 
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)
<:P_SEMI .$E >
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 12 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<RETURN .$ST .RTN >)>>>
<SET $ST <:P_EXCEPTARMS .$E .$ST >>
<:P_END .$E "END in EXCEPT...END">
>) (T <RETURN>)>> 
><:RETURN-ERROR>>
<SETG :P_EXCEPT$TYPE :STMT >
<SET PROCLIST <CONS :P_EXCEPTARMS .PROCLIST>> 

<DEFINE :P_EXCEPTARMS ( $E $ST  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($ST )ANY (VALUE)<LIST FIX ANY>)
<PROG ($ARMS $XS )#DECL ( ($ARMS )<VECTOR UVECTOR FIX FIX FIX>($XS )<VECTOR <VECTOR UVECTOR FIX FIX FIX><LIST FIX ANY>ANY >)

<SET $ARMS <ARRAY$CREATE 1 >>
<SET $XS [.$ARMS <ONEOF$MAKE 2 NIL >.$ST ]>
<SET :ABS <ONEOF$MAKE 7 .$XS >>
<REPEAT () <COND (T 
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)
<SET $K <:P_ENV$NEXT_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 41 >
<PROG ($NAMES $VARS $BOD )#DECL ( ($NAMES )<VECTOR UVECTOR FIX FIX FIX>($VARS )<LIST FIX ANY>($BOD )<VECTOR <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>>)
<:P_ENV$NEXT_TOKEN .$E >
<:P_ENV$NEW_LEVEL .$E >
<SET $NAMES <:P_NAMELIST .$E >>
<SET $VARS <:P_WHENDECL .$E >>
<SET $BOD <:P_CBODY .$E 2 ": in WHEN...: body">>
<ARRAY$ADDH .$ARMS [.$BOD .$NAMES .$VARS ]>
<:P_ENV$POP_LEVEL .$E >
>)
(<==? .TG 25 >
<PROG ($DEC $BOD )#DECL ( ($DEC )<LIST FIX ANY>($BOD )<VECTOR <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>>)
<:P_ENV$NEXT_TOKEN .$E >
<:P_ENV$NEW_LEVEL .$E >
<SET $DEC <:P_MDECL .$E >>
<SET $BOD <:P_CBODY .$E 3 ": in OTHERS...: body">>
<RECORD$PUT 2 .$XS <ONEOF$MAKE 1 [.$BOD .$DEC ]>>
<:P_ENV$POP_LEVEL .$E >
>)(T 
<RETURN ,:ABS .RTN >)>>>
>) (T <RETURN>)>> 
><:RETURN-ERROR>>
<SETG :P_EXCEPTARMS$TYPE O$4887$16$0 >
<SET PROCLIST <CONS :P_MDECL .PROCLIST>> 

<DEFINE :P_MDECL ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($K $DEC )#DECL ( ($K )<LIST FIX ANY>($DEC )<VECTOR <VECTOR UVECTOR FIX FIX FIX>ANY >)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 22 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<RETURN <ONEOF$MAKE 2 NIL >.RTN >)>>>
<SET $DEC <:P_DECL .$E >>
<COND (<INT$GT <ARRAY$SIZE <RECORD$GET 1 .$DEC >>1 >
<:P_ENV$ERR .$E "more than one idn declared"1 >)(T 
#FALSE () )>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 29 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<:P_ENV$ASSUME .$E ") in (idn: type)">)>>>
<RETURN <ONEOF$MAKE 1 .$DEC >.RTN >
><:RETURN-ERROR>>
<SETG :P_MDECL$TYPE O$4887$2$1 >
<SET PROCLIST <CONS :P_CBODY .PROCLIST>> 

<DEFINE :P_CBODY ( $E $KIND $ASSUME  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($KIND )FIX ($ASSUME )STRING (VALUE)<VECTOR <VECTOR UVECTOR FIX FIX FIX><VECTOR UVECTOR FIX FIX FIX>>)
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 3 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<:P_ENV$ASSUME .$E .$ASSUME >)>>>
<RETURN <:P_BODY .$E .$KIND >.RTN >
><:RETURN-ERROR>>
<SETG :P_CBODY$TYPE R$4887$2$0 >
<SET PROCLIST <CONS :P_WHENDECL .PROCLIST>> 

<DEFINE :P_WHENDECL ( $E  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY (VALUE)<LIST FIX ANY>)
<PROG ($K $DEC )#DECL ( ($K )<LIST FIX ANY>($DEC )<LIST FIX ANY>)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 22 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<RETURN <ONEOF$MAKE 2 NIL >.RTN >)>>>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 24 >
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 13 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E >
<SET $DEC <ONEOF$MAKE 3 NIL >>
>)(T 
<SET $DEC <ONEOF$MAKE 1 <:P_DECLLIST .$E >>>)>>>)(T 
<SET $DEC <ONEOF$MAKE 1 <:P_DECLLIST .$E >>>)>>>
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 29 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<:P_ENV$ASSUME .$E ") in (decllist) or (*)">)>>>
<RETURN .$DEC .RTN >
><:RETURN-ERROR>>
<SETG :P_WHENDECL$TYPE O$4887$3$0 >
<SET PROCLIST <CONS :P_END .PROCLIST>> 

<DEFINE :P_END ( $E $ASSUME  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($ASSUME )STRING )
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)

<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<==? .TG 10 >
<:P_ENV$NEXT_TOKEN .$E >)(T 
<:P_ENV$ASSUME .$E .$ASSUME >)>>>
>DONE >
<SET PROCLIST <CONS :P_FIND_A_STMT .PROCLIST>> 

<DEFINE :P_FIND_A_STMT ( $E $KIND  "OPTIONAL" (HANDLERS ()) "NAME" RTN)
#DECL ( ($E )ANY ($KIND )FIX (VALUE)<OR ATOM FALSE>)
<PROG ($FLUSHED $B $FOUND )#DECL ( ($FLUSHED )<OR ATOM FALSE>($B )<OR ATOM FALSE>($FOUND )<OR ATOM FALSE>)

<SET $FLUSHED #FALSE () >
<SET $B T >
<SET $FOUND #FALSE () >
<REPEAT () <COND (.$B 
<PROG ($K )#DECL ( ($K )<LIST FIX ANY>)
<SET $K <:P_ENV$GET_PEEK_TOKEN .$E >>
<PROG (OLDGUY) #DECL ((OLDGUY) <LIST FIX ANY>) <SET OLDGUY .$K ><PROG (TG $K ) #DECL ((TG) FIX) <SET TG <NTH .OLDGUY 1>><SET $K <NTH .OLDGUY 2>> <COND 
(<OR <==? .TG 8 ><==? .TG 9 >>
<COND (<INT$EQUAL .$KIND 0 >
<SET $B #FALSE () >)(T 
#FALSE () )>)
(<==? .TG 37 >
<COND (<INT$EQUAL .$KIND 1 >
<SET $B #FALSE () >)(T 
#FALSE () )>)
(<==? .TG 41 >
<COND (<INT$EQUAL .$KIND 2 >
<SET $B #FALSE () >)(T 
#FALSE () )>)
(<==? .TG 25 >
<COND (<OR <INT$EQUAL .$KIND 1 ><INT$EQUAL .$KIND 2 >>
<SET $B #FALSE () >)(T 
#FALSE () )>)
(<OR <==? .TG 10 ><==? .TG 5 ><==? .TG 30 ><==? .TG 43 ><==? .TG 42 ><==? .TG 19 ><==? .TG 15 ><==? .TG 39 ><==? .TG 11 >>
<SET $B #FALSE () >)
(<OR <==? .TG 34 ><==? .TG 12 >>
<PROG ()
<SET $FOUND T >
<SET $B #FALSE () >>)
(<==? .TG 31 >
<PROG ()
<:P_ENV$NEXT_TOKEN .$E>
<SET $FOUND T >
<SET $B #FALSE () >
>)(T 
#FALSE () )>>>
<COND (.$B 
<PROG ()
<COND (<BOOL$NOT .$FLUSHED >
<PROG ()
<:P_ENV$ERR .$E "looking for a stmt"2 >
<SET $FLUSHED T >
>)(T 
#FALSE () )>
<:P_ENV$NEXT_TOKEN .$E >
>)(T 
#FALSE () )>
>) (T <RETURN>)>> 
<COND (.$FLUSHED 
<:P_ENV$ERR .$E "resuming parse at this point"0 >)(T 
#FALSE () )>
<RETURN .$FOUND .RTN >
><:RETURN-ERROR>>
<SETG :P_FIND_A_STMT$TYPE :BOOL >
<SETG R$4887$2$0'(:RECORD (:ARRAY :EQUATE )(:ARRAY :STMT ))>
<SETG R$4887$2$1'(:RECORD (:ARRAY :IDN )(:ARRAY :EXPR ))>
<SETG R$4887$2$2'(:RECORD (:ARRAY :IDN ):TYPESPEC )>
<SETG R$4887$2$3'(:RECORD (:ARRAY R$4887$2$2 ):EXPR )>
<SETG R$4887$2$4'(:RECORD R$4887$2$0 O$4887$2$1 )>
<SETG R$4887$2$5'(:RECORD :NAME (:ARRAY :NAME ))>
<SETG R$4887$2$6'(:RECORD (:ARRAY R$4887$2$7 )O$4887$2$3 )>
<SETG R$4887$2$7'(:RECORD R$4887$2$0 :EXPR )>
<SETG R$4887$2$8'(:RECORD (:ARRAY :EXPR ):NAME )>
<SETG R$4887$2$9'(:RECORD :EXPR :EXPR )>
<SETG R$4887$3$0'(:RECORD (:ARRAY R$4887$3$1 )O$4887$2$0 :STMT )>
<SETG R$4887$3$1'(:RECORD R$4887$2$0 (:ARRAY :NAME )O$4887$3$0 )>
<SETG R$4887$3$2'(:RECORD R$4887$2$0 R$4887$3$3 O$4887$2$2 )>
<SETG R$4887$3$3'(:RECORD :EXPR (:ARRAY :EXPR )O$4887$3$1 )>
<SETG R$4887$3$4'(:RECORD (:ARRAY R$4887$3$5 ):EXPR O$4887$2$3 )>
<SETG R$4887$3$5'(:RECORD R$4887$2$0 (:ARRAY :NAME )O$4887$2$1 )>
<SETG O$4887$2$0'(:ONEOF R$4887$2$4 :NULL )>
<SETG O$4887$2$1'(:ONEOF R$4887$2$2 :NULL )>
<SETG O$4887$2$2'(:ONEOF (:ARRAY R$4887$2$2 )(:ARRAY :IDN ))>
<SETG O$4887$2$3'(:ONEOF R$4887$2$0 :NULL )>
<SETG O$4887$3$0'(:ONEOF (:ARRAY R$4887$2$2 ):NULL :NULL )>
<SETG O$4887$3$1'(:ONEOF :IDN (:ARRAY R$4887$2$5 ):NULL )>
<SETG O$4887$16$0'(:ONEOF R$4887$2$1 :NULL R$4887$2$0 :NULL R$4887$2$2 R$4887$2$3 R$4887$3$0 R$4887$3$2 R$4887$2$6 R$4887$3$3 (:ARRAY :EXPR )R$4887$2$8 R$4887$2$9 R$4887$3$4 R$4887$2$7 (:ARRAY :EXPR ))>
